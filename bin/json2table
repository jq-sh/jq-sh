#!/usr/bin/env bash

preprocess() {
  resource="$resource" resources=$resources extract_resource
}

script="$1"
if [[ -f "$script" ]]; then
  shift
  _resource="${script/*\/}"
  resource="${resource:-${_resource%.table}}"
else
  # nope not a script
  unset script

  # --- TODO tidy this up
  if [[ "${BASH_SOURCE[0]}" != "json2table" ]]; then
    _resource="${resource:-${BASH_SOURCE[0]/*\/}}"
    resource="${resource:-${_resource%.table}}"
  fi

  STDIN_FILE=$(mktemp)
  cat > "$STDIN_FILE"
  find_cols=$(preprocess < "$STDIN_FILE" | identify_cols)
  # --- TODO tidy this up
fi



COLS=$(eval echo "${cols:-${@}}") # Nb. `eval echo "$cols"` allows x.{y1,y2} expansion
SORT_BY=${sort_by:-}
MISSING_KEY=${MISSING_KEY:-Â¿}

color_missing() {
  COLOR=41 color "$MISSING_KEY"
}

source_script() {
  # Not sure why this doesn't work
  # source <(sed -n '/^#/, /^__JQ__$/{//!p;}' "$1")
  # ... so we'll just go with a temp file...
  TEMP_FILE=$(mktemp)
  sed -n '/^#/, /^__JQ__$/{//!p;}' "$1" > "$TEMP_FILE"
  # shellcheck disable=SC1090
  source "$TEMP_FILE"
}

cols_for() { local resource=$1
  {
    cols_key="${resource}_cols[@]"
    resource_cols=${!cols_key}
    if [[ -z "${resource_cols}" ]]; then
      echo "${COLS:-${cols[@]:-${find_cols}}}"
    else
      echo "${resource_cols}"
    fi

    cols_key_add="${resource}_cols_add[@]"
    resource_cols_add=${!cols_key_add}
    if [[ -z "${resource_cols_add}" ]]; then
      echo "${cols_add[@]:-}"
    else
      echo "${resource_cols_add}"
    fi
  } | xargs
}

sort_by_for() { local resource=$1
  sort_by_key="${resource}_sort_by[@]"
  resource_sort_by=${!sort_by_key}
  if [[ -z "${resource_sort_by}" ]]; then
    echo "${SORT_BY:-${sort_by[@]:-}}"
  else
    echo "${resource_sort_by}"
  fi
}

term() {
  for term in "$@"; do
    [[ -n "$term" ]] && echo "\<$term\>"
  done
}

# TODO - DRY this up...
color_terms_for() { local resource=$1
  term "(false|FALSE|FAILURE)"
  term "(true|TRUE|SUCCESS)"
  term null

  color_terms_key="${resource}_color_terms[@]"
  resource_color_terms=( "${!color_terms_key}" )
  if [[ -n "${resource_color_terms_str}" ]]; then
    resource_color_terms=( $(echo "${resource_color_terms_str}") )
    term "${resource_color_terms[@]}"
  else
    if [[ -z "${resource_color_terms[*]}" ]]; then
      if [[ -n "${color_terms_str}" ]]; then
        color_terms=( $(echo "${color_terms_str}") )
        term "${color_terms[@]}"
      else
        term "${color_terms[@]}"
      fi
    else
      term "${resource_color_terms[@]}"
    fi
  fi

  color_terms_add_key="${resource}_color_terms_add[@]"
  resource_color_terms_add=( "${!color_terms_add_key}" )
  if [[ -n "${resource_color_terms_add_str}" ]]; then
    resource_color_terms_add=( $(echo "${resource_color_terms_add_str}") )
    term "${resource_color_terms_add[@]}"
  else
    if [[ -z "${resource_color_terms_add[*]}" ]]; then
      if [[ -n "${color_terms_add_str}" ]]; then
        color_terms_add=( $(echo "${color_terms_add_str}") )
        term "${color_terms_add[@]}"
      else
        term "${color_terms_add[@]}"
      fi
    else
      term "${resource_color_terms_add[@]}"
    fi
  fi


  ${COLORIZE_TIMESTAMPS:-false} && term '20[0-9][0-9]-[0-1][0-9]-[0-3][0-9]T[0-2][0-9]:[0-5][0-9]:[0-9]'{0..9}Z
}

color_terms_str=${color_terms:-}
color_terms_str_key="${resource}_color_terms"
resource_color_terms_str="${!color_terms_str_key:-}"
color_terms_add_str=${color_terms_add:-}
color_terms_add_str_key="${resource}_color_terms_add"
resource_color_terms_add_str="${!color_terms_add_str_key:-}"

[[ -f "$script" ]] && source_script "$script"

if [[ ${conf:-} = "${HOME:-~}" ]]; then
  conf="${conf}/.json2table/${resource:-}.conf"
fi

# shellcheck disable=SC1090
if [[ -f "${conf:-}" ]]; then
  source "$conf"
fi


read -r -a cols < <(cols_for "$resource")
# >&2 echo "cols[${#cols}]=[${cols[*]}]"

read -r -a sort_by < <(sort_by_for "$resource")
# >&2 echo "sort_by=[${sort_by[*]}]"

# Nb. unlike cols & sort_by color_terms can have spaces in them
# so have to be handled differently
IFS0=$IFS; IFS=$'\n'; for term in $(color_terms_for "$resource"); do
  color_terms_a+=( "$term" )
done; IFS=$IFS0
# >&2 echo "color_terms_a=[${color_terms_a[*]}]"


if [[ -f "$script" ]]; then
  preprocess |
    jq-sh "$script"
else
  # TODO - remove this _second_ preprocess for non-scripts
  preprocess < "$STDIN_FILE"
fi |
  # TODO wonder if this can be removed?
  jq --compact-output --slurp  . |
  json2jsonl "${sort_by[@]}"     |
  jsonl2tsv "${cols[@]}"         |
  tsv2table                      |
  color "${color_terms_a[@]}"    |
  color_missing
