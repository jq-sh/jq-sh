#!/usr/bin/env asciinema-rec_script

# Given some JSON
json=$(cat shpecs/support/super_heroes.json | jq --compact-output '.members')
echo "$json"

# Pipe that into a table with some cols of our choosing:
echo "$json" | cols="name secretIdentity:secret_identity" json2table
# (Note the `secretIdentity` column alias follows the `:`)

# Or use JSONL (ie. a stream/lines of JSON) instead:
json=$(cat shpecs/support/super_heroes.json | jq --compact-output '.members[]')
echo "$json"

# Which produces the same result:
echo "$json" | cols="name secretIdentity:secret_identity" json2table

# Alternatively, the `cols` can be specified as arguments
echo "$json" | json2table age name

# Or `json2table` can just use the keys from the first record as `cols`
echo "$json" | json2table

# There's a `sort_by`, which can take multiple fields
echo "$json" | sort_by="gender age" json2table name gender age

# And a `reverse`
echo "$json" | sort_by="gender age" reverse=true json2table name gender age

# As well as `color_terms`
echo "$json" | color_terms="$(echo "(male|Man) female" | tr ' ' '\n')" json2table name gender age


# Meanwhile, given the surrounding JSON
json=$(jq --compact-output < shpecs/support/super_heroes.json)
echo "$json"

# A `resource` can be extracted from that JSON
echo "$json" | resource=location json2table

# ... and cols can be specified as arguments
echo "$json" | resource=location json2table secretBase homeTown

# Or if there are multiple values of the `resource`
echo "$json" | resource=member   json2table name secretIdentity:secret_identity

echo "$json" | resources=members json2table name secretIdentity:secret_identity

# Instead of passing in `resource` as an env var, `json2table` can be symlinked to,
# then it will take the name of the script as the value of `<resource>.table`
/bin/ls -goG shpecs/support/member.table
echo "$json" | ./shpecs/support/member.table name secretIdentity:secret_identity

# Or specialized `json2table` scripts can be written like this one:
bat shpecs/support/super_hero_member.table

# And then given this JSON:
json=$(jq --compact-output '.members[]' < shpecs/support/super_heroes.json)
echo "$json"

# And after adding it in the path...
export PATH=./shpecs/support:$PATH

# `cols`, `color_terms` & `sort_by` are now defined in `super_hero_member.table`
echo "$json" | super_hero_member.table
# Notice also, that the `"powers"` array had been pre-processed by some `jq` code.
# ie. the `.powers |= join(", ")` code that following the `__JQ__` marker
# To leave us with these `powers`:
#   "Radiation resistance, Turning tiny, Radiation blast"
# Instead of:
#   ["Radiation resistance","Turning tiny","Radiation blast"]


# So, much like `jq-sh` brings `sh` & `jq` together into one script,
# a `json2table` can include both `json2table` configuration _and_ `jq` code.


# And again `cols` can be overridden like so:
echo "$json" | cols="name secretIdentity:secret_identity" super_hero_member.table

# Or using `{{resource}}_cols` (if multiple tables are rendered globally)
echo "$json" | super_hero_member_cols="name age" super_hero_member.table

# Or again, the `cols` can just be passed in as arguments...
echo "$json" | super_hero_member.table age name

# And `sort_by` can also be overridden
echo "$json" | sort_by="age" super_hero_member.table

# Or using the `{{resource}}_sort_by` version
echo "$json" | super_hero_member_sort_by="age" super_hero_member.table

# (Nb. we can even `sort_by` `"gender"` even though its not in the `cols` list)
echo "$json" | super_hero_member_sort_by="gender age" super_hero_member.table

# And `title` can also be overridden
echo "$json" | title="Super Folks" super_hero_member.table

# Or using the `{{resource}}_title` version
echo "$json" | super_hero_member_title="Super Dooper Folks" super_hero_member.table

