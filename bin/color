#!/usr/bin/env bash--script
# --help
## color
#
# Its like grep but doesn't filter out lines & each search term gets its own color!
#
### EXAMPLES
# * `echo -e "help hello worlod \nwhoa" |                         color 'whoa|wo'          ' he'      'lo '`
# * `(set -- 'whoa|wo' ' he' 'lo '; IFS=$'\n'; echo "$*")> /tmp/patterns.txt ; echo -e "help hello worlod \nwhoa" | patterns_file=/tmp/patterns.txt color` # read patterns in from a file
# * `while date; do sleep 1; done |                               color '^[A-Z][a-z][a-z]'            ' [A-Z][a-z][a-z]'  ':[0-9][0-9]:' '[0-9]'{0..9}' '`
# * `while date; do sleep 1; done |                               color '^[A-Z][a-z][a-z]' SKIP_GREEN ' [A-Z][a-z][a-z]'  ':[0-9][0-9]:' '[0-9]'{0..9}' '`
# * `while date; do sleep 1; done |                      COLOR=42 color '^[A-Z][a-z][a-z]'            ' [A-Z][a-z][a-z]'  ':[0-9][0-9]:' '[0-9]'{0..9}' '`
# * `while date; do sleep 1; done | COLOR_EFFECTS="3;4;" COLOR=42 color '^[A-Z][a-z][a-z]'            ' [A-Z][a-z][a-z]'  ':[0-9][0-9]:' '[0-9]'{0..9}' '`

COLOR=${COLOR:-31}                 # Defaults to red
COLOR_EFFECTS=${COLOR_EFFECTS:-1;} # Defaults to bold
SKIP_COLORS=${SKIP_COLORS:-"$(seq -s' ' 37 40) $(seq -s' ' 47 90) 98 99 103"}
MAX_COLOR=${MAX_COLOR:-106}
MIN_COLOR=${MIN_COLOR:-$COLOR}

next_color() {
  color=$(($1+1))

  while echo "$SKIP_COLORS" | grep -w -q "$color"; do
    color=$((color+1))
  done

  [ "$color" -lt "$MAX_COLOR" ] && echo "$color"
}

highlight() {
  GREP_COLOR="${COLOR_EFFECTS}${COLOR}" grep -E --color=always --line-buffered "$1|$"
  # ag --case-sensitive --color --color-match "${COLOR_EFFECTS}${COLOR}" "$1|$"
}

color() { pattern="${1:-}"; shift
  debug "COLOR=[$COLOR] pattern='$pattern'"
  highlight "$pattern" |
    if [ $# -eq 0 ]; then
      cat
    else
      COLOR="$(next_color "$COLOR" || echo "$MIN_COLOR")" color "$@"
    fi
}

color_count() {
  # Nb. currently there's only `25` colors, but lets figure it out dynamically in case our code changes...
  local colors=("$COLOR")
  while COLOR="$(next_color "$COLOR")"; do
    colors+=("$COLOR")
  done
  echo $((${#colors[@]} + 1))
}


# Given arguments
# eg.
# ```
# foo bar baz biz buz goo gar giz guz
# ```
# Group them together based on a COUNT
# So,
# * `COUNT=3`
# ```
# foo|bar|baz biz|buz|goo gar|giz|guz
# ```
# * `COUNT=2`
# ```
# foo|baz|buz|gar|guz bar|biz|goo|giz
# ```
# * `COUNT=1`
# ```
# foo|bar|baz|biz|buz|goo|gar|giz|guz
# ```
color_grouped() {
  COLOR_COUNT=${COLOR_COUNT:-$(color_count)}

  assign_group() {
    local group_index=$((i++ % COLOR_COUNT))
    groups[group_index]="${groups[group_index]:+${groups[group_index]}|}$1"
  }

  # Initialize arrays for groups
  declare -a groups

  # Distribute arguments into groups based on COLOR_COUNT
  local i=0
  if [ -s "${patterns_file:-}" ]; then
    debug "grouping patterns from patterns_file=${patterns_file} ..."
    while IFS= read -u 3 -r pattern || [ -n "$pattern" ]; do
      assign_group "$pattern"
    done 3< "$patterns_file"
  else
    debug "grouping patterns from ARGS ..."
    for pattern in "$@"; do
      assign_group "$pattern"
    done
  fi

  debug "groups: $(printf "%q " "${groups[@]}")"
  color "${groups[@]}"
}

# color "$@"
color_grouped "$@"
